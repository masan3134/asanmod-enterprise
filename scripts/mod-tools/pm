#!/bin/bash
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ASANMOD v10: PM2 ALIAS WRAPPER - Enhanced Edition
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Usage: ./scripts/mod-tools/pm <env> <action> [service]
#
# Examples:
#   ./scripts/mod-tools/pm prod status           # All prod services status
#   ./scripts/mod-tools/pm prod restart backend  # Restart prod backend
#   ./scripts/mod-tools/pm dev logs frontend     # Show dev frontend logs
#   ./scripts/mod-tools/pm prod restart all      # Restart all prod services
#   ./scripts/mod-tools/pm prod health           # Quick health check
#   ./scripts/mod-tools/pm prod memory           # Memory usage summary
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Don't use set -e - PM2 commands may return non-zero for valid reasons
# Instead, handle errors explicitly

ENV="${1:-}"
ACTION="${2:-}"
SERVICE="${3:-}"

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Timing
START_TIME=$(date +%s%N)

print_usage() {
    echo ""
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${GREEN}${BOLD}ASANMOD v10: PM2 ALIAS WRAPPER${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo "Usage: ./scripts/mod-tools/pm <env> <action> [service]"
    echo ""
    echo -e "${YELLOW}Environments:${NC}"
    echo "  dev     Development environment (ports 3000/3001)"
    echo "  prod    Production environment (ports 8204/8205)"
    echo ""
    echo -e "${YELLOW}Actions:${NC}"
    echo "  start       Start service(s)"
    echo "  stop        Stop service(s)"
    echo "  restart     Restart service(s)"
    echo "  reload      Graceful reload (cluster mode only)"
    echo "  status      Show status"
    echo "  logs        Show logs (last 100 lines)"
    echo "  logs-live   Show real-time logs (streaming)"
    echo "  flush       Clear logs"
    echo "  describe    Show detailed service info"
    echo "  monit       Open PM2 monitor (interactive)"
    echo "  health      Quick health check"
    echo "  memory      Memory usage summary"
    echo "  errors      ğŸ¤– AI: Scan for recent errors (UTC+3)"
    echo "  diag        ğŸ¤– AI: Full diagnostic report"
    echo "  save        Save PM2 process list for startup"
    echo ""
    echo -e "${YELLOW}Services:${NC}"
    echo "  frontend  Frontend service"
    echo "  backend   Backend service"
    echo "  brain     IKAI Brain (prod only)"
    echo "  all       All services for the environment"
    echo ""
    echo -e "${YELLOW}Examples:${NC}"
    echo "  ./scripts/mod-tools/pm prod status"
    echo "  ./scripts/mod-tools/pm prod restart backend"
    echo "  ./scripts/mod-tools/pm dev logs frontend"
    echo "  ./scripts/mod-tools/pm prod restart all"
    echo "  ./scripts/mod-tools/pm prod health"
    echo ""
    exit 1
}

print_duration() {
    local END_TIME=$(date +%s%N)
    local DURATION=$(( (END_TIME - START_TIME) / 1000000 ))
    echo -e "${CYAN}â±  Completed in ${DURATION}ms${NC}"
}

log_success() {
    echo -e "${GREEN}âœ… $1${NC}"
}

log_error() {
    echo -e "${RED}âŒ $1${NC}"
}

log_warn() {
    echo -e "${YELLOW}âš ï¸  $1${NC}"
}

log_info() {
    echo -e "${BLUE}â„¹ï¸  $1${NC}"
}

# Validate inputs
if [[ -z "$ENV" || -z "$ACTION" ]]; then
    print_usage
fi

if [[ "$ENV" != "dev" && "$ENV" != "prod" ]]; then
    log_error "Invalid environment: $ENV"
    echo "   Valid options: dev, prod"
    exit 1
fi

# Map service names to PM2 process names
get_pm2_name() {
    local env=$1
    local service=$2

    case "$env-$service" in
        "dev-frontend")  echo "ikai-dev-frontend" ;;
        "dev-backend")   echo "ikai-dev-backend" ;;
        "prod-frontend") echo "ikai-prod-frontend" ;;
        "prod-backend")  echo "ikai-prod-backend" ;;
        "prod-brain")    echo "ikai-brain" ;;
        *)
            echo ""
            return 1
            ;;
    esac
}

# Get all services for an environment
get_all_services() {
    local env=$1
    if [[ "$env" == "prod" ]]; then
        echo "ikai-prod-frontend ikai-prod-backend ikai-brain"
    else
        echo "ikai-dev-frontend ikai-dev-backend"
    fi
}

# Check if service is running
is_service_running() {
    local name=$1
    pm2 jlist 2>/dev/null | grep -q "\"name\":\"$name\"" && \
    pm2 jlist 2>/dev/null | grep -A5 "\"name\":\"$name\"" | grep -q '"status":"online"'
}

# Get service memory usage
get_memory_usage() {
    local name=$1
    pm2 jlist 2>/dev/null | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    for proc in data:
        if proc.get('name') == '$name':
            mem = proc.get('monit', {}).get('memory', 0)
            print(f'{mem / 1024 / 1024:.1f}MB')
            break
except:
    print('N/A')
" 2>/dev/null || echo "N/A"
}

# Execute PM2 command with error handling
execute_pm2() {
    local action=$1
    local target=$2
    local show_output=${3:-true}

    if [[ "$show_output" == "true" ]]; then
        echo -e "${BLUE}â–¶ pm2 $action $target${NC}"
    fi

    if pm2 $action $target 2>&1; then
        return 0
    else
        local exit_code=$?
        log_error "Command failed with exit code: $exit_code"
        return $exit_code
    fi
}

# Quick health check
health_check() {
    echo -e "${MAGENTA}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${BOLD}ğŸ¥ PM2 Health Check: $ENV${NC}"
    echo -e "${MAGENTA}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""

    local all_healthy=true
    local services=$(get_all_services "$ENV")

    for service in $services; do
        local status_icon
        local status_text
        local memory

        if is_service_running "$service"; then
            status_icon="${GREEN}â—${NC}"
            status_text="${GREEN}online${NC}"
            memory=$(get_memory_usage "$service")
        else
            status_icon="${RED}â—‹${NC}"
            status_text="${RED}offline${NC}"
            memory="-"
            all_healthy=false
        fi

        printf "  %b %-25s %b  %s\n" "$status_icon" "$service" "$status_text" "$memory"
    done

    echo ""
    if [[ "$all_healthy" == "true" ]]; then
        log_success "All $ENV services are healthy"
    else
        log_warn "Some services are not running"
    fi
}

# Memory summary
memory_summary() {
    echo -e "${MAGENTA}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${BOLD}ğŸ’¾ Memory Usage: $ENV${NC}"
    echo -e "${MAGENTA}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""

    local total_mem=0
    local services=$(get_all_services "$ENV")

    for service in $services; do
        if is_service_running "$service"; then
            local mem_str=$(get_memory_usage "$service")
            local mem_val=${mem_str%MB}
            if [[ "$mem_val" != "N/A" ]]; then
                total_mem=$(echo "$total_mem + $mem_val" | bc 2>/dev/null || echo "$total_mem")
            fi
            printf "  %-25s %s\n" "$service" "$mem_str"
        else
            printf "  %-25s ${RED}offline${NC}\n" "$service"
        fi
    done

    echo ""
    echo -e "  ${BOLD}Total:${NC} ${total_mem}MB"
}

# AI-Responsive Error Scanner
# Scans logs for errors in the last N minutes with UTC+3 timestamps
errors_scan() {
    local minutes=${SERVICE:-5}  # Default 5 minutes
    local current_time=$(TZ='Europe/Istanbul' date '+%Y-%m-%d %H:%M:%S')
    local cutoff_time=$(TZ='Europe/Istanbul' date -d "$minutes minutes ago" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || date '+%Y-%m-%d %H:%M:%S')

    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "ğŸ” ERROR SCAN - $ENV Environment"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "Current Time (UTC+3): $current_time"
    echo "Scanning errors from last $minutes minutes"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo ""

    local services=$(get_all_services "$ENV")
    local total_errors=0
    local has_critical=false

    for service in $services; do
        local log_file="/root/.pm2/logs/${service}-error.log"
        local out_file="/root/.pm2/logs/${service}-out.log"

        echo "[$service]"

        if [[ ! -f "$log_file" ]]; then
            echo "  No error log file found"
            echo ""
            continue
        fi

        # Get recent errors with timestamps
        local recent_errors=$(tail -200 "$log_file" 2>/dev/null | grep -E "Error|error|ERROR|FATAL|fatal|Exception|exception|Cannot|cannot|Failed|failed|ENOENT|ECONNREFUSED|MODULE_NOT_FOUND|SyntaxError|TypeError|ReferenceError" | tail -20)

        if [[ -z "$recent_errors" ]]; then
            echo "  âœ… No recent errors"
        else
            local error_count=$(echo "$recent_errors" | wc -l)
            total_errors=$((total_errors + error_count))
            echo "  âš ï¸  Found $error_count error(s):"
            echo ""
            echo "$recent_errors" | while read -r line; do
                # Extract timestamp if present and convert to readable format
                echo "    $line" | head -c 500
                echo ""
            done
        fi

        # Check for build errors in out log
        local build_errors=$(tail -100 "$out_file" 2>/dev/null | grep -E "Build failed|Compilation failed|Module not found|Cannot find module|SyntaxError|Unexpected token" | tail -5)

        if [[ -n "$build_errors" ]]; then
            has_critical=true
            echo ""
            echo "  ğŸ”´ BUILD ERRORS DETECTED:"
            echo "$build_errors" | while read -r line; do
                echo "    $line" | head -c 500
                echo ""
            done
        fi

        echo ""
    done

    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo "SUMMARY"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo "Total Errors Found: $total_errors"
    echo "Critical Build Errors: $has_critical"
    echo "Scan Time (UTC+3): $current_time"

    if [[ "$has_critical" == "true" ]]; then
        echo ""
        echo "â›” ACTION REQUIRED: Build errors detected. Services may not be running correctly."
    elif [[ $total_errors -gt 0 ]]; then
        echo ""
        echo "âš ï¸  Review errors above. Some may be transient."
    else
        echo ""
        echo "âœ… No errors detected in $ENV environment."
    fi
}

# AI-Responsive Diagnostic Report
# Comprehensive status for AI agents
diagnostic_report() {
    local current_time=$(TZ='Europe/Istanbul' date '+%Y-%m-%d %H:%M:%S')

    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "ğŸ“‹ DIAGNOSTIC REPORT - $ENV Environment"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "Report Time (UTC+3): $current_time"
    echo ""

    echo "## SERVICE STATUS"
    echo ""

    local services=$(get_all_services "$ENV")
    local all_healthy=true

    for service in $services; do
        local status="offline"
        local memory="N/A"
        local uptime="N/A"
        local restarts="N/A"

        if is_service_running "$service"; then
            status="online"
            memory=$(get_memory_usage "$service")

            # Get uptime and restarts from PM2
            local pm2_info=$(pm2 jlist 2>/dev/null | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    for proc in data:
        if proc.get('name') == '$service':
            pm2_env = proc.get('pm2_env', {})
            uptime = pm2_env.get('pm_uptime', 0)
            restarts = pm2_env.get('restart_time', 0)
            import time
            uptime_sec = int((time.time() * 1000 - uptime) / 1000) if uptime else 0
            if uptime_sec < 60:
                uptime_str = f'{uptime_sec}s'
            elif uptime_sec < 3600:
                uptime_str = f'{uptime_sec // 60}m'
            else:
                uptime_str = f'{uptime_sec // 3600}h {(uptime_sec % 3600) // 60}m'
            print(f'{uptime_str}|{restarts}')
            break
except:
    print('N/A|N/A')
" 2>/dev/null)

            uptime=$(echo "$pm2_info" | cut -d'|' -f1)
            restarts=$(echo "$pm2_info" | cut -d'|' -f2)
        else
            all_healthy=false
        fi

        echo "- $service: $status (Memory: $memory, Uptime: $uptime, Restarts: $restarts)"
    done

    echo ""
    echo "## RECENT ERRORS (Last 5 minutes)"
    echo ""

    for service in $services; do
        local log_file="/root/.pm2/logs/${service}-error.log"

        if [[ -f "$log_file" ]]; then
            local error_count
            error_count=$(tail -100 "$log_file" 2>/dev/null | grep -cE "Error|error|ERROR|FATAL" 2>/dev/null | awk '{print $1+0}')
            error_count=${error_count:-0}

            if [[ "$error_count" -gt 0 ]]; then
                echo "- $service: $error_count error(s) in recent logs"
                tail -3 "$log_file" 2>/dev/null | while read -r line; do
                    echo "  > $(echo "$line" | head -c 200)"
                done
            else
                echo "- $service: No recent errors"
            fi
        fi
    done

    echo ""
    echo "## CONCLUSION"
    echo ""

    if [[ "$all_healthy" == "true" ]]; then
        echo "âœ… All services are running normally."
    else
        echo "âš ï¸ Some services are not running. Restart may be required."
    fi

    echo ""
    echo "Report generated at: $current_time (UTC+3)"
}

# Handle actions that don't need a service
case "$ACTION" in
    "status")
        if [[ -z "$SERVICE" ]]; then
            echo -e "${GREEN}ğŸ“Š PM2 Status (All Services)${NC}"
            pm2 status
            print_duration
            exit 0
        fi
        ;;
    "flush")
        if [[ -z "$SERVICE" || "$SERVICE" == "all" ]]; then
            echo -e "${YELLOW}ğŸ§¹ Flushing all PM2 logs...${NC}"
            pm2 flush
            log_success "Logs flushed"
            print_duration
            exit 0
        fi
        ;;
    "health")
        health_check
        print_duration
        exit 0
        ;;
    "memory")
        memory_summary
        print_duration
        exit 0
        ;;
    "save")
        echo -e "${BLUE}ğŸ’¾ Saving PM2 process list...${NC}"
        pm2 save
        log_success "PM2 process list saved"
        print_duration
        exit 0
        ;;
    "monit")
        echo -e "${BLUE}ğŸ“º Opening PM2 monitor...${NC}"
        pm2 monit
        exit 0
        ;;
    "errors")
        errors_scan
        print_duration
        exit 0
        ;;
    "diag"|"diagnostic")
        diagnostic_report
        print_duration
        exit 0
        ;;
esac

# For other actions, service is required
if [[ -z "$SERVICE" ]]; then
    log_error "Service not specified"
    print_usage
fi

# Handle "all" services
if [[ "$SERVICE" == "all" ]]; then
    TARGETS=$(get_all_services "$ENV")
    echo -e "${GREEN}ğŸ¯ Target: $ENV all services${NC}"

    local success_count=0
    local fail_count=0

    for target in $TARGETS; do
        if execute_pm2 "$ACTION" "$target"; then
            ((success_count++))
        else
            ((fail_count++))
        fi
    done

    echo ""
    if [[ $fail_count -eq 0 ]]; then
        log_success "All $success_count services processed successfully"
    else
        log_warn "$success_count succeeded, $fail_count failed"
    fi
    print_duration
    exit 0
fi

# Get the PM2 process name
PM2_NAME=$(get_pm2_name "$ENV" "$SERVICE")

if [[ -z "$PM2_NAME" ]]; then
    log_error "Invalid service: $SERVICE for environment: $ENV"
    echo ""
    echo "Valid services:"
    echo "  dev:  frontend, backend"
    echo "  prod: frontend, backend, brain"
    exit 1
fi

echo -e "${GREEN}ğŸ¯ Target: $PM2_NAME${NC}"

# Pre-action checks
case "$ACTION" in
    "reload")
        # Check if service is in cluster mode
        local exec_mode=$(pm2 jlist 2>/dev/null | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    for proc in data:
        if proc.get('name') == '$PM2_NAME':
            print(proc.get('exec_mode', 'unknown'))
            break
except:
    print('unknown')
" 2>/dev/null || echo "unknown")

        if [[ "$exec_mode" == "fork_mode" ]]; then
            log_warn "$PM2_NAME is in fork mode. Reload acts like restart."
            log_info "Use 'restart' for fork mode services."
        fi
        ;;
esac

# Execute the command
case "$ACTION" in
    "start"|"stop"|"restart"|"reload"|"delete")
        if execute_pm2 "$ACTION" "$PM2_NAME"; then
            log_success "$ACTION completed for $PM2_NAME"
        else
            log_error "$ACTION failed for $PM2_NAME"
            exit 1
        fi
        ;;
    "logs")
        # Non-streaming logs - safe for agents
        echo -e "${BLUE}ğŸ“œ Last 100 lines for $PM2_NAME${NC}"
        pm2 logs "$PM2_NAME" --lines 100 --nostream
        ;;
    "logs-live")
        # Live streaming logs - interactive only
        if [ -t 1 ]; then
            echo -e "${BLUE}ğŸ“œ Streaming logs for $PM2_NAME (Ctrl+C to exit)${NC}"
            pm2 logs "$PM2_NAME" --lines 50
        else
            log_warn "logs-live requires interactive terminal. Using logs instead."
            pm2 logs "$PM2_NAME" --lines 100 --nostream
        fi
        ;;
    "status"|"describe")
        pm2 describe "$PM2_NAME"
        ;;
    *)
        log_error "Invalid action: $ACTION"
        print_usage
        ;;
esac

print_duration
